(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{665:function(e,t,a){"use strict";a.r(t);var o=a(1),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"applications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#applications"}},[e._v("#")]),e._v(" Applications")]),e._v(" "),a("p",[e._v("Please ensure you've first read the spec for "),a("RouterLink",{attrs:{to:"/spec/abci/abci.html"}},[e._v("ABCI Methods and Types")])],1),e._v(" "),a("p",[e._v("Here we cover the following components of ABCI applications:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#state"}},[e._v("Connection State")]),e._v(" - the interplay between ABCI connections and application state\nand the differences between "),a("code",[e._v("CheckTx")]),e._v(" and "),a("code",[e._v("DeliverTx")]),e._v(".")]),e._v(" "),a("li",[a("a",{attrs:{href:"#transaction-results"}},[e._v("Transaction Results")]),e._v(" - rules around transaction\nresults and validity")]),e._v(" "),a("li",[a("a",{attrs:{href:"#validator-updates"}},[e._v("Validator Set Updates")]),e._v(" - how validator sets are\nchanged during "),a("code",[e._v("InitChain")]),e._v(" and "),a("code",[e._v("EndBlock")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#query"}},[e._v("Query")]),e._v(" - standards for using the "),a("code",[e._v("Query")]),e._v(" method and proofs about the\napplication state")]),e._v(" "),a("li",[a("a",{attrs:{href:"#crash-recovery"}},[e._v("Crash Recovery")]),e._v(" - handshake protocol to synchronize\nTendermint and the application on startup.")])]),e._v(" "),a("h2",{attrs:{id:"state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[e._v("#")]),e._v(" State")]),e._v(" "),a("p",[e._v("Since Tendermint maintains three concurrent ABCI connections, it is typical\nfor an application to maintain a distinct state for each, and for the states to\nbe synchronized during "),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"commit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit"}},[e._v("#")]),e._v(" Commit")]),e._v(" "),a("p",[e._v("Application state should only be persisted to disk during "),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("p",[e._v("Before "),a("code",[e._v("Commit")]),e._v(" is called, Tendermint locks and flushes the mempool so that no new messages will\nbe received on the mempool connection. This provides an opportunity to safely update all three\nstates to the latest committed state at once.")]),e._v(" "),a("p",[e._v("When "),a("code",[e._v("Commit")]),e._v(" completes, it unlocks the mempool.")]),e._v(" "),a("p",[e._v("WARNING: if the ABCI app logic processing the "),a("code",[e._v("Commit")]),e._v(" message sends a\n"),a("code",[e._v("/broadcast_tx_sync")]),e._v(" or "),a("code",[e._v("/broadcast_tx_commit")]),e._v(" and waits for the response\nbefore proceeding, it will deadlock. Executing those "),a("code",[e._v("broadcast_tx")]),e._v(" calls\ninvolves acquiring a lock that is held during the "),a("code",[e._v("Commit")]),e._v(" call, so it's not\npossible. If you make the call to the "),a("code",[e._v("broadcast_tx")]),e._v(" endpoints concurrently,\nthat's no problem, it just can't be part of the sequential logic of the\n"),a("code",[e._v("Commit")]),e._v(" function.")]),e._v(" "),a("h3",{attrs:{id:"consensus-connection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus-connection"}},[e._v("#")]),e._v(" Consensus Connection")]),e._v(" "),a("p",[e._v("The Consensus Connection should maintain a "),a("code",[e._v("DeliverTxState")]),e._v(" -\nthe working state for block execution. It should be updated by the calls to\n"),a("code",[e._v("BeginBlock")]),e._v(", "),a("code",[e._v("DeliverTx")]),e._v(", and "),a("code",[e._v("EndBlock")]),e._v(' during block execution and committed to\ndisk as the "latest committed state" during '),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("p",[e._v("Updates made to the DeliverTxState by each method call must be readable by each subsequent method -\nie. the updates are linearizable.")]),e._v(" "),a("h3",{attrs:{id:"mempool-connection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mempool-connection"}},[e._v("#")]),e._v(" Mempool Connection")]),e._v(" "),a("p",[e._v("The Mempool Connection should maintain a "),a("code",[e._v("CheckTxState")]),e._v("\nto sequentially process pending transactions in the mempool that have\nnot yet been committed. It should be initialized to the latest committed state\nat the end of every "),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("p",[e._v("The CheckTxState may be updated concurrently with the DeliverTxState, as\nmessages may be sent concurrently on the Consensus and Mempool connections. However,\nbefore calling "),a("code",[e._v("Commit")]),e._v(", Tendermint will lock and flush the mempool connection,\nensuring that all existing CheckTx are responded to and no new ones can\nbegin.")]),e._v(" "),a("p",[e._v("After "),a("code",[e._v("Commit")]),e._v(", CheckTx is run again on all transactions that remain in the\nnode's local mempool after filtering those included in the block. To prevent the\nmempool from rechecking all transactions every time a block is committed, set\nthe configuration option "),a("code",[e._v("mempool.recheck=false")]),e._v(". As of Tendermint v0.32.1,\nan additional "),a("code",[e._v("Type")]),e._v(" parameter is made available to the CheckTx function that\nindicates whether an incoming transaction is new ("),a("code",[e._v("CheckTxType_New")]),e._v("), or a\nrecheck ("),a("code",[e._v("CheckTxType_Recheck")]),e._v(").")]),e._v(" "),a("p",[e._v("Finally, the mempool will unlock and new transactions can be processed through CheckTx again.")]),e._v(" "),a("p",[e._v("Note that CheckTx doesn't have to check everything that affects transaction validity; the\nexpensive things can be skipped. In fact, CheckTx doesn't have to check\nanything; it might say that any transaction is a valid transaction.\nUnlike DeliverTx, CheckTx is just there as\na sort of weak filter to keep invalid transactions out of the blockchain. It's\nweak, because a Byzantine node doesn't care about CheckTx; it can propose a\nblock full of invalid transactions if it wants.")]),e._v(" "),a("h3",{attrs:{id:"info-connection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#info-connection"}},[e._v("#")]),e._v(" Info Connection")]),e._v(" "),a("p",[e._v("The Info Connection should maintain a "),a("code",[e._v("QueryState")]),e._v(" for answering queries from the user,\nand for initialization when Tendermint first starts up (both described further\nbelow).\nIt should always contain the latest committed state associated with the\nlatest committed block.")]),e._v(" "),a("p",[e._v("QueryState should be set to the latest "),a("code",[e._v("DeliverTxState")]),e._v(" at the end of every "),a("code",[e._v("Commit")]),e._v(",\nie. after the full block has been processed and the state committed to disk.\nOtherwise it should never be modified.")]),e._v(" "),a("h2",{attrs:{id:"transaction-results"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transaction-results"}},[e._v("#")]),e._v(" Transaction Results")]),e._v(" "),a("p",[a("code",[e._v("ResponseCheckTx")]),e._v(" and "),a("code",[e._v("ResponseDeliverTx")]),e._v(" contain the same fields.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("Info")]),e._v(" and "),a("code",[e._v("Log")]),e._v(" fields are non-deterministic values for debugging/convenience purposes\nthat are otherwise ignored.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("Data")]),e._v(" field must be strictly deterministic, but can be arbitrary data.")]),e._v(" "),a("h3",{attrs:{id:"gas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gas"}},[e._v("#")]),e._v(" Gas")]),e._v(" "),a("p",[e._v("Ethereum introduced the notion of "),a("code",[e._v("gas")]),e._v(" as an abstract representation of the\ncost of resources used by nodes when processing transactions. Every operation in the\nEthereum Virtual Machine uses some amount of gas, and gas can be accepted at a market-variable price.\nUsers propose a maximum amount of gas for their transaction; if the tx uses less, they get\nthe difference credited back. Tendermint adopts a similar abstraction,\nthough uses it only optionally and weakly, allowing applications to define\ntheir own sense of the cost of execution.")]),e._v(" "),a("p",[e._v("In Tendermint, the "),a("code",[e._v("ConsensusParams.Block.MaxGas")]),e._v(" limits the amount of "),a("code",[e._v("gas")]),e._v(" that can be used in a block.\nThe default value is "),a("code",[e._v("-1")]),e._v(", meaning no limit, or that the concept of gas is\nmeaningless.")]),e._v(" "),a("p",[e._v("Responses contain a "),a("code",[e._v("GasWanted")]),e._v(" and "),a("code",[e._v("GasUsed")]),e._v(" field. The former is the maximum\namount of gas the sender of a tx is willing to use, and the later is how much it actually\nused. Applications should enforce that "),a("code",[e._v("GasUsed <= GasWanted")]),e._v(" - ie. tx execution\nshould halt before it can use more resources than it requested.")]),e._v(" "),a("p",[e._v("When "),a("code",[e._v("MaxGas > -1")]),e._v(", Tendermint enforces the following rules:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("GasWanted <= MaxGas")]),e._v(" for all txs in the mempool")]),e._v(" "),a("li",[a("code",[e._v("(sum of GasWanted in a block) <= MaxGas")]),e._v(" when proposing a block")])]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("MaxGas == -1")]),e._v(", no rules about gas are enforced.")]),e._v(" "),a("p",[e._v("Note that Tendermint does not currently enforce anything about Gas in the consensus, only the mempool.\nThis means it does not guarantee that committed blocks satisfy these rules!\nIt is the application's responsibility to return non-zero response codes when gas limits are exceeded.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("GasUsed")]),e._v(" field is ignored completely by Tendermint. That said, applications should enforce:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("GasUsed <= GasWanted")]),e._v(" for any given transaction")]),e._v(" "),a("li",[a("code",[e._v("(sum of GasUsed in a block) <= MaxGas")]),e._v(" for every block")])]),e._v(" "),a("p",[e._v("In the future, we intend to add a "),a("code",[e._v("Priority")]),e._v(" field to the responses that can be\nused to explicitly prioritize txs in the mempool for inclusion in a block\nproposal. See "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/1861",target:"_blank",rel:"noopener noreferrer"}},[e._v("#1861"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"checktx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checktx"}},[e._v("#")]),e._v(" CheckTx")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("Code != 0")]),e._v(", it will be rejected from the mempool and hence\nnot broadcasted to other peers and not included in a proposal block.")]),e._v(" "),a("p",[a("code",[e._v("Data")]),e._v(" contains the result of the CheckTx transaction execution, if any. It is\nsemantically meaningless to Tendermint.")]),e._v(" "),a("p",[a("code",[e._v("Tags")]),e._v(" include any tags for the execution, though since the transaction has not\nbeen committed yet, they are effectively ignored by Tendermint.")]),e._v(" "),a("h3",{attrs:{id:"delivertx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delivertx"}},[e._v("#")]),e._v(" DeliverTx")]),e._v(" "),a("p",[e._v("If DeliverTx returns "),a("code",[e._v("Code != 0")]),e._v(", the transaction will be considered invalid,\nthough it is still included in the block.")]),e._v(" "),a("p",[a("code",[e._v("Data")]),e._v(" contains the result of the CheckTx transaction execution, if any. It is\nsemantically meaningless to Tendermint.")]),e._v(" "),a("p",[e._v("Both the "),a("code",[e._v("Code")]),e._v(" and "),a("code",[e._v("Data")]),e._v(" are included in a structure that is hashed into the\n"),a("code",[e._v("LastResultsHash")]),e._v(" of the next block header.")]),e._v(" "),a("p",[a("code",[e._v("Tags")]),e._v(" include any tags for the execution, which Tendermint will use to index\nthe transaction by. This allows transactions to be queried according to what\nevents took place during their execution.")]),e._v(" "),a("p",[e._v("See issue "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/1007",target:"_blank",rel:"noopener noreferrer"}},[e._v("#1007"),a("OutboundLink")],1),e._v(" for how\nthe tags will be hashed into the next block header.")]),e._v(" "),a("h2",{attrs:{id:"validator-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validator-updates"}},[e._v("#")]),e._v(" Validator Updates")]),e._v(" "),a("p",[e._v("The application may set the validator set during InitChain, and update it during\nEndBlock.")]),e._v(" "),a("p",[e._v("Note that the maximum total power of the validator set is bounded by\n"),a("code",[e._v("MaxTotalVotingPower = MaxInt64 / 8")]),e._v(". Applications are responsible for ensuring\nthey do not make changes to the validator set that cause it to exceed this\nlimit.")]),e._v(" "),a("p",[e._v("Additionally, applications must ensure that a single set of updates does not contain any duplicates -\na given public key can only appear in an update once. If an update includes\nduplicates, the block execution will fail irrecoverably.")]),e._v(" "),a("h3",{attrs:{id:"initchain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initchain"}},[e._v("#")]),e._v(" InitChain")]),e._v(" "),a("p",[e._v("ResponseInitChain can return a list of validators.\nIf the list is empty, Tendermint will use the validators loaded in the genesis\nfile.\nIf the list is not empty, Tendermint will use it for the validator set.\nThis way the application can determine the initial validator set for the\nblockchain.")]),e._v(" "),a("h3",{attrs:{id:"endblock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#endblock"}},[e._v("#")]),e._v(" EndBlock")]),e._v(" "),a("p",[e._v("Updates to the Tendermint validator set can be made by returning\n"),a("code",[e._v("ValidatorUpdate")]),e._v(" objects in the "),a("code",[e._v("ResponseEndBlock")]),e._v(":")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"",base64:"bWVzc2FnZSBWYWxpZGF0b3JVcGRhdGUgewogIFB1YktleSBwdWJfa2V5CiAgaW50NjQgcG93ZXIKfQoKbWVzc2FnZSBQdWJLZXkgewogIHN0cmluZyB0eXBlCiAgYnl0ZXMgIGRhdGEKfQo="}}),e._v(" "),a("p",[e._v("The "),a("code",[e._v("pub_key")]),e._v(" currently supports only one type:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v('type = "ed25519"')]),e._v(" and "),a("code",[e._v("data = <raw 32-byte public key>")])])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("power")]),e._v(" is the new voting power for the validator, with the\nfollowing rules:")]),e._v(" "),a("ul",[a("li",[e._v("power must be non-negative")]),e._v(" "),a("li",[e._v("if power is 0, the validator must already exist, and will be removed from the\nvalidator set")]),e._v(" "),a("li",[e._v("if power is non-0:\n"),a("ul",[a("li",[e._v("if the validator does not already exist, it will be added to the validator\nset with the given power")]),e._v(" "),a("li",[e._v("if the validator does already exist, its power will be adjusted to the given power")])])]),e._v(" "),a("li",[e._v("the total power of the new validator set must not exceed MaxTotalVotingPower")])]),e._v(" "),a("p",[e._v("Note the updates returned in block "),a("code",[e._v("H")]),e._v(" will only take effect at block "),a("code",[e._v("H+2")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"consensus-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus-parameters"}},[e._v("#")]),e._v(" Consensus Parameters")]),e._v(" "),a("p",[e._v("ConsensusParams enforce certain limits in the blockchain, like the maximum size\nof blocks, amount of gas used in a block, and the maximum acceptable age of\nevidence. They can be set in InitChain and updated in EndBlock.")]),e._v(" "),a("h3",{attrs:{id:"block-maxbytes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-maxbytes"}},[e._v("#")]),e._v(" Block.MaxBytes")]),e._v(" "),a("p",[e._v("The maximum size of a complete Amino encoded block.\nThis is enforced by Tendermint consensus.")]),e._v(" "),a("p",[e._v("This implies a maximum tx size that is this MaxBytes, less the expected size of\nthe header, the validator set, and any included evidence in the block.")]),e._v(" "),a("p",[e._v("Must have "),a("code",[e._v("0 < MaxBytes < 100 MB")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"block-maxgas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-maxgas"}},[e._v("#")]),e._v(" Block.MaxGas")]),e._v(" "),a("p",[e._v("The maximum of the sum of "),a("code",[e._v("GasWanted")]),e._v(" in a proposed block.\nThis is "),a("em",[e._v("not")]),e._v(" enforced by Tendermint consensus.\nIt is left to the app to enforce (ie. if txs are included past the\nlimit, they should return non-zero codes). It is used by Tendermint to limit the\ntxs included in a proposed block.")]),e._v(" "),a("p",[e._v("Must have "),a("code",[e._v("MaxGas >= -1")]),e._v(".\nIf "),a("code",[e._v("MaxGas == -1")]),e._v(", no limit is enforced.")]),e._v(" "),a("h3",{attrs:{id:"block-timeiotams"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-timeiotams"}},[e._v("#")]),e._v(" Block.TimeIotaMs")]),e._v(" "),a("p",[e._v("The minimum time between consecutive blocks (in milliseconds).\nThis is enforced by Tendermint consensus.")]),e._v(" "),a("p",[e._v("Must have "),a("code",[e._v("TimeIotaMs > 0")]),e._v(" to ensure time monotonicity.")]),e._v(" "),a("h3",{attrs:{id:"evidenceparams-maxage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#evidenceparams-maxage"}},[e._v("#")]),e._v(" EvidenceParams.MaxAge")]),e._v(" "),a("p",[e._v("This is the maximum age of evidence.\nThis is enforced by Tendermint consensus.\nIf a block includes evidence older than this, the block will be rejected\n(validators won't vote for it).")]),e._v(" "),a("p",[e._v("Must have "),a("code",[e._v("MaxAge > 0")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updates"}},[e._v("#")]),e._v(" Updates")]),e._v(" "),a("p",[e._v("The application may set the ConsensusParams during InitChain, and update them during\nEndBlock. If the ConsensusParams is empty, it will be ignored. Each field\nthat is not empty will be applied in full. For instance, if updating the\nBlock.MaxBytes, applications must also set the other Block fields (like\nBlock.MaxGas), even if they are unchanged, as they will otherwise cause the\nvalue to be updated to 0.")]),e._v(" "),a("h4",{attrs:{id:"initchain-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initchain-2"}},[e._v("#")]),e._v(" InitChain")]),e._v(" "),a("p",[e._v("ResponseInitChain includes a ConsensusParams.\nIf its nil, Tendermint will use the params loaded in the genesis\nfile. If it's not nil, Tendermint will use it.\nThis way the application can determine the initial consensus params for the\nblockchain.")]),e._v(" "),a("h4",{attrs:{id:"endblock-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#endblock-2"}},[e._v("#")]),e._v(" EndBlock")]),e._v(" "),a("p",[e._v("ResponseEndBlock includes a ConsensusParams.\nIf its nil, Tendermint will do nothing.\nIf it's not nil, Tendermint will use it.\nThis way the application can update the consensus params over time.")]),e._v(" "),a("p",[e._v("Note the updates returned in block "),a("code",[e._v("H")]),e._v(" will take effect right away for block\n"),a("code",[e._v("H+1")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"query"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query"}},[e._v("#")]),e._v(" Query")]),e._v(" "),a("p",[e._v("Query is a generic method with lots of flexibility to enable diverse sets\nof queries on application state. Tendermint makes use of Query to filter new peers\nbased on ID and IP, and exposes Query to the user over RPC.")]),e._v(" "),a("p",[e._v("Note that calls to Query are not replicated across nodes, but rather query the\nlocal node's state - hence they may return stale reads. For reads that require\nconsensus, use a transaction.")]),e._v(" "),a("p",[e._v("The most important use of Query is to return Merkle proofs of the application state at some height\nthat can be used for efficient application-specific lite-clients.")]),e._v(" "),a("p",[e._v("Note Tendermint has technically no requirements from the Query\nmessage for normal operation - that is, the ABCI app developer need not implement\nQuery functionality if they do not wish too.")]),e._v(" "),a("h3",{attrs:{id:"query-proofs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query-proofs"}},[e._v("#")]),e._v(" Query Proofs")]),e._v(" "),a("p",[e._v("The Tendermint block header includes a number of hashes, each providing an\nanchor for some type of proof about the blockchain. The "),a("code",[e._v("ValidatorsHash")]),e._v(" enables\nquick verification of the validator set, the "),a("code",[e._v("DataHash")]),e._v(" gives quick\nverification of the transactions included in the block, etc.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("AppHash")]),e._v(" is unique in that it is application specific, and allows for\napplication-specific Merkle proofs about the state of the application.\nWhile some applications keep all relevant state in the transactions themselves\n(like Bitcoin and its UTXOs), others maintain a separated state that is\ncomputed deterministically "),a("em",[e._v("from")]),e._v(" transactions, but is not contained directly in\nthe transactions themselves (like Ethereum contracts and accounts).\nFor such applications, the "),a("code",[e._v("AppHash")]),e._v(" provides a much more efficient way to verify lite-client proofs.")]),e._v(" "),a("p",[e._v("ABCI applications can take advantage of more efficient lite-client proofs for\ntheir state as follows:")]),e._v(" "),a("ul",[a("li",[e._v("return the Merkle root of the deterministic application state in\n"),a("code",[e._v("ResponseCommit.Data")]),e._v(".")]),e._v(" "),a("li",[e._v("it will be included as the "),a("code",[e._v("AppHash")]),e._v(" in the next block.")]),e._v(" "),a("li",[e._v("return efficient Merkle proofs about that application state in "),a("code",[e._v("ResponseQuery.Proof")]),e._v("\nthat can be verified using the "),a("code",[e._v("AppHash")]),e._v(" of the corresponding block.")])]),e._v(" "),a("p",[e._v("For instance, this allows an application's lite-client to verify proofs of\nabsence in the application state, something which is much less efficient to do using the block hash.")]),e._v(" "),a("p",[e._v('Some applications (eg. Ethereum, Cosmos-SDK) have multiple "levels" of Merkle trees,\nwhere the leaves of one tree are the root hashes of others. To support this, and\nthe general variability in Merkle proofs, the '),a("code",[e._v("ResponseQuery.Proof")]),e._v(" has some minimal structure:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"",base64:"bWVzc2FnZSBQcm9vZiB7CiAgcmVwZWF0ZWQgUHJvb2ZPcCBvcHMKfQoKbWVzc2FnZSBQcm9vZk9wIHsKICBzdHJpbmcgdHlwZSA9IDE7CiAgYnl0ZXMga2V5ID0gMjsKICBieXRlcyBkYXRhID0gMzsKfQo="}}),e._v(" "),a("p",[e._v("Each "),a("code",[e._v("ProofOp")]),e._v(" contains a proof for a single key in a single Merkle tree, of the specified "),a("code",[e._v("type")]),e._v(".\nThis allows ABCI to support many different kinds of Merkle trees, encoding\nformats, and proofs (eg. of presence and absence) just by varying the "),a("code",[e._v("type")]),e._v(".\nThe "),a("code",[e._v("data")]),e._v(" contains the actual encoded proof, encoded according to the "),a("code",[e._v("type")]),e._v(".\nWhen verifying the full proof, the root hash for one ProofOp is the value being\nverified for the next ProofOp in the list. The root hash of the final ProofOp in\nthe list should match the "),a("code",[e._v("AppHash")]),e._v(" being verified against.")]),e._v(" "),a("h3",{attrs:{id:"peer-filtering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peer-filtering"}},[e._v("#")]),e._v(" Peer Filtering")]),e._v(" "),a("p",[e._v("When Tendermint connects to a peer, it sends two queries to the ABCI application\nusing the following paths, with no additional data:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("/p2p/filter/addr/<IP:PORT>")]),e._v(", where "),a("code",[e._v("<IP:PORT>")]),e._v(" denote the IP address and\nthe port of the connection")]),e._v(" "),a("li",[a("code",[e._v("p2p/filter/id/<ID>")]),e._v(", where "),a("code",[e._v("<ID>")]),e._v(" is the peer node ID (ie. the\npubkey.Address() for the peer's PubKey)")])]),e._v(" "),a("p",[e._v("If either of these queries return a non-zero ABCI code, Tendermint will refuse\nto connect to the peer.")]),e._v(" "),a("h3",{attrs:{id:"paths"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paths"}},[e._v("#")]),e._v(" Paths")]),e._v(" "),a("p",[e._v("Queries are directed at paths, and may optionally include additional data.")]),e._v(" "),a("p",[e._v("The expectation is for there to be some number of high level paths\ndifferentiating concerns, like "),a("code",[e._v("/p2p")]),e._v(", "),a("code",[e._v("/store")]),e._v(", and "),a("code",[e._v("/app")]),e._v(". Currently,\nTendermint only uses "),a("code",[e._v("/p2p")]),e._v(", for filtering peers. For more advanced use, see the\nimplementation of\n"),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/v0.23.1/baseapp/baseapp.go#L333",target:"_blank",rel:"noopener noreferrer"}},[e._v("Query in the Cosmos-SDK"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"crash-recovery"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#crash-recovery"}},[e._v("#")]),e._v(" Crash Recovery")]),e._v(" "),a("p",[e._v("On startup, Tendermint calls the "),a("code",[e._v("Info")]),e._v(" method on the Info Connection to get the latest\ncommitted state of the app. The app MUST return information consistent with the\nlast block it succesfully completed Commit for.")]),e._v(" "),a("p",[e._v("If the app succesfully committed block H but not H+1, then "),a("code",[e._v("last_block_height = H")]),e._v(" and "),a("code",[e._v("last_block_app_hash = <hash returned by Commit for block H>")]),e._v(". If the app\nfailed during the Commit of block H, then "),a("code",[e._v("last_block_height = H-1")]),e._v(" and\n"),a("code",[e._v("last_block_app_hash = <hash returned by Commit for block H-1, which is the hash in the header of block H>")]),e._v(".")]),e._v(" "),a("p",[e._v("We now distinguish three heights, and describe how Tendermint syncs itself with\nthe app.")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"",base64:"c3RvcmVCbG9ja0hlaWdodCA9IGhlaWdodCBvZiB0aGUgbGFzdCBibG9jayBUZW5kZXJtaW50IHNhdyBhIGNvbW1pdCBmb3IKc3RhdGVCbG9ja0hlaWdodCA9IGhlaWdodCBvZiB0aGUgbGFzdCBibG9jayBmb3Igd2hpY2ggVGVuZGVybWludCBjb21wbGV0ZWQgYWxsCiAgICBibG9jayBwcm9jZXNzaW5nIGFuZCBzYXZlZCBhbGwgQUJDSSByZXN1bHRzIHRvIGRpc2sKYXBwQmxvY2tIZWlnaHQgPSBoZWlnaHQgb2YgdGhlIGxhc3QgYmxvY2sgZm9yIHdoaWNoIEFCQ0kgYXBwIHN1Y2Nlc2Z1bGx5CiAgICBjb21wbGV0ZWQgQ29tbWl0Cg=="}}),e._v(" "),a("p",[e._v("Note we always have "),a("code",[e._v("storeBlockHeight >= stateBlockHeight")]),e._v(" and "),a("code",[e._v("storeBlockHeight >= appBlockHeight")]),e._v("\nNote also we never call Commit on an ABCI app twice for the same height.")]),e._v(" "),a("p",[e._v("The procedure is as follows.")]),e._v(" "),a("p",[e._v("First, some simple start conditions:")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("appBlockHeight == 0")]),e._v(", then call InitChain.")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("storeBlockHeight == 0")]),e._v(", we're done.")]),e._v(" "),a("p",[e._v("Now, some sanity checks:")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("storeBlockHeight < appBlockHeight")]),e._v(", error\nIf "),a("code",[e._v("storeBlockHeight < stateBlockHeight")]),e._v(", panic\nIf "),a("code",[e._v("storeBlockHeight > stateBlockHeight+1")]),e._v(", panic")]),e._v(" "),a("p",[e._v("Now, the meat:")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("storeBlockHeight == stateBlockHeight && appBlockHeight < storeBlockHeight")]),e._v(",\nreplay all blocks in full from "),a("code",[e._v("appBlockHeight")]),e._v(" to "),a("code",[e._v("storeBlockHeight")]),e._v(".\nThis happens if we completed processing the block, but the app forgot its height.")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("storeBlockHeight == stateBlockHeight && appBlockHeight == storeBlockHeight")]),e._v(", we're done.\nThis happens if we crashed at an opportune spot.")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("storeBlockHeight == stateBlockHeight+1")]),e._v("\nThis happens if we started processing the block but didn't finish.")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("appBlockHeight < stateBlockHeight")]),e._v("\nreplay all blocks in full from "),a("code",[e._v("appBlockHeight")]),e._v(" to "),a("code",[e._v("storeBlockHeight-1")]),e._v(",\nand replay the block at "),a("code",[e._v("storeBlockHeight")]),e._v(" using the WAL.\nThis happens if the app forgot the last block it committed.")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("appBlockHeight == stateBlockHeight")]),e._v(",\nreplay the last block (storeBlockHeight) in full.\nThis happens if we crashed before the app finished Commit")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("appBlockHeight == storeBlockHeight")]),e._v("\nupdate the state using the saved ABCI responses but dont run the block against the real app.\nThis happens if we crashed after the app finished Commit but before Tendermint saved the state.")])],1)}),[],!1,null,null,null);t.default=n.exports}}]);