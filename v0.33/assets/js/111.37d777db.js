(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{758:function(e,t,a){"use strict";a.r(t);var i=a(1),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"adr-047-handling-evidence-from-light-client"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adr-047-handling-evidence-from-light-client"}},[e._v("#")]),e._v(" ADR 047: Handling evidence from light client")]),e._v(" "),a("h2",{attrs:{id:"changelog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),a("ul",[a("li",[e._v("18-02-2020: Initial draft")]),e._v(" "),a("li",[e._v("24-02-2020: Second version")])]),e._v(" "),a("h2",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),a("p",[e._v("If the light client is under attack, either directly -> lunatic/phantom\nvalidators (light fork) or indirectly -> full fork, it's supposed to halt and\nsend evidence of misbehavior to a correct full node. Upon receiving an\nevidence, the full node should punish malicious validators (if possible).")]),e._v(" "),a("h2",{attrs:{id:"decision"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#decision"}},[e._v("#")]),e._v(" Decision")]),e._v(" "),a("p",[e._v("When a light client sees two conflicting headers ("),a("code",[e._v("H1.Hash() != H2.Hash()")]),e._v(",\n"),a("code",[e._v("H1.Height == H2.Height")]),e._v("), both having 1/3+ of the voting power of the\ncurrently trusted validator set, it will submit a "),a("code",[e._v("ConflictingHeadersEvidence")]),e._v("\nto all full nodes it's connected to. Evidence needs to be submitted to all full\nnodes since there's no way to determine which full node is correct (honest).")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBDb25mbGljdGluZ0hlYWRlcnNFdmlkZW5jZSBzdHJ1Y3QgewogIEgxIHR5cGVzLlNpZ25lZEhlYWRlcgogIEgyIHR5cGVzLlNpZ25lZEhlYWRlcgp9Cg=="}}),e._v(" "),a("p",[e._v("When a full node receives the "),a("code",[e._v("ConflictingHeadersEvidence")]),e._v(" evidence, it should\na) validate it b) figure out if malicious behaviour is obvious (immediately\nslashable) or the fork accountability protocol needs to be started.")]),e._v(" "),a("h3",{attrs:{id:"validating-headers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validating-headers"}},[e._v("#")]),e._v(" Validating headers")]),e._v(" "),a("p",[e._v("Check both headers are valid ("),a("code",[e._v("ValidateBasic")]),e._v("), have the same height, and\nsigned by 1/3+ of the validator set that the full node had at height\n"),a("code",[e._v("H1.Height-1")]),e._v(".")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Q: What if light client validator set is not equal to full node's validator\nset (i.e. from full node's point of view both headers are not properly signed;\nthis includes the case where none of the two headers were committed on the\nmain chain)")]),e._v(" "),a("p",[e._v("Reject the evidence. It means light client is following a fork, but, hey, at\nleast it will halt.")])]),e._v(" "),a("li",[a("p",[e._v("Q: Don't we want to punish validators who signed something else even if they\nhave less or equal than 1/3?")]),e._v(" "),a("p",[e._v("No consensus so far. Ethan said no, Zarko said yes.\nhttps://github.com/tendermint/spec/pull/71#discussion_r374210533")])])]),e._v(" "),a("h3",{attrs:{id:"figuring-out-if-malicious-behaviour-is-immediately-slashable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#figuring-out-if-malicious-behaviour-is-immediately-slashable"}},[e._v("#")]),e._v(" Figuring out if malicious behaviour is immediately slashable")]),e._v(" "),a("p",[e._v("Let's say H1 was committed from this full node's perspective (see Appendix A).\nIntersect validator sets of H1 and H2.")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("if there are signers(H2) that are not part of validators(H1), they misbehaved as\nthey are signing protocol messages in heights they are not validators =>\nimmediately slashable (#F4).")])]),e._v(" "),a("li",[a("p",[e._v("if "),a("code",[e._v("H1.Round == H2.Round")]),e._v(", and some signers signed different precommit\nmessages in both commits, then it is an equivocation misbehavior => immediately\nslashable (#F1).")])]),e._v(" "),a("li",[a("p",[e._v("if "),a("code",[e._v("H1.Round != H2.Round")]),e._v(" we need to run full detection procedure => not\nimmediately slashable.")])]),e._v(" "),a("li",[a("p",[e._v("if "),a("code",[e._v("ValidatorsHash")]),e._v(", "),a("code",[e._v("NextValidatorsHash")]),e._v(", "),a("code",[e._v("ConsensusHash")]),e._v(",\n"),a("code",[e._v("AppHash")]),e._v(", and "),a("code",[e._v("LastResultsHash")]),e._v(" in H2 are different (incorrect application\nstate transition), then it is a lunatic misbehavior => immediately slashable (#F5).")])])]),e._v(" "),a("p",[e._v("If evidence is not immediately slashable, fork accountability needs to invoked\n(ADR does not yet exist).")]),e._v(" "),a("p",[e._v("It's unclear if we should further break up "),a("code",[e._v("ConflictingHeadersEvidence")]),e._v(" or\ngossip and commit it directly. See\nhttps://github.com/tendermint/tendermint/issues/4182#issuecomment-590339233")]),e._v(" "),a("p",[e._v("If we'd go without breaking evidence, all we'll need to do is to strip the\ncommitted header from "),a("code",[e._v("ConflictingHeadersEvidence")]),e._v(" (H1) and leave only the\nuncommitted header (H2):")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBDb25mbGljdGluZ0hlYWRlckV2aWRlbmNlIHN0cnVjdCB7CiAgSCB0eXBlcy5TaWduZWRIZWFkZXIKfQo="}}),e._v(" "),a("p",[e._v("If we'd go with breaking evidence, here are the types we'll need:")]),e._v(" "),a("h3",{attrs:{id:"f1-equivocation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#f1-equivocation"}},[e._v("#")]),e._v(" F1. Equivocation")]),e._v(" "),a("p",[e._v("Existing "),a("code",[e._v("DuplicateVoteEvidence")]),e._v(" needs to be created and gossiped.")]),e._v(" "),a("h3",{attrs:{id:"f4-phantom-validators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#f4-phantom-validators"}},[e._v("#")]),e._v(" F4. Phantom validators")]),e._v(" "),a("p",[e._v("A new type of evidence needs to be created:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBQaGFudG9tVmFsaWRhdG9yRXZpZGVuY2Ugc3RydWN0IHsKICBQdWJLZXkgY3J5cHRvLlB1YktleQogIFZvdGUgdHlwZXMuVm90ZQp9Cg=="}}),e._v(" "),a("p",[e._v("It contains a validator's public key and a vote for a block, where this\nvalidator is not part of the validator set.")]),e._v(" "),a("h3",{attrs:{id:"f5-lunatic-validator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#f5-lunatic-validator"}},[e._v("#")]),e._v(" F5. Lunatic validator")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBMdW5hdGljVmFsaWRhdG9yRXZpZGVuY2Ugc3RydWN0IHsKICBIZWFkZXIgdHlwZXMuSGVhZGVyCiAgVm90ZSB0eXBlcy5Wb3RlCn0K"}}),e._v(" "),a("p",[e._v("To punish this attack, we need support for a new Evidence type -\n"),a("code",[e._v("LunaticValidatorEvidence")]),e._v(". This type includes a vote and a header. The header\nmust contain fields that are invalid with respect to the previous block, and a\nvote for that header by a validator that was in a validator set within the\nunbonding period. While the attack is only possible if +1/3 of some validator\nset colludes, the evidence should be verifiable independently for each\nindividual validator. This means the total evidence can be split into one piece\nof evidence per attacking validator and gossipped to nodes to be verified one\npiece at a time, reducing the DoS attack surface at the peer layer.")]),e._v(" "),a("p",[e._v("Note it is not sufficient to simply compare this header with that committed for\nthe corresponding height, as an honest node may vote for a header that is not\nultimately committed. Certain fields may also be variable, for instance the\n"),a("code",[e._v("LastCommitHash")]),e._v(" and the "),a("code",[e._v("Time")]),e._v(" may depend on which votes the proposer includes.\nThus, the header must be explicitly checked for invalid data.")]),e._v(" "),a("p",[e._v("For the attack to succeed, VC must sign a header that changes the validator set\nto consist of something they control. Without doing this, they can not\notherwise attack the light client, since the client verifies commits according\nto validator sets. Thus, it should be sufficient to check only that\n"),a("code",[e._v("ValidatorsHash")]),e._v(" and "),a("code",[e._v("NextValidatorsHash")]),e._v(" are correct with respect to the\nheader that was committed at the corresponding height.")]),e._v(" "),a("p",[e._v("That said, if the attack is conducted by +2/3 of the validator set, they don't\nneed to make an invalid change to the validator set, since they already control\nit. Instead they would make invalid changes to the "),a("code",[e._v("AppHash")]),e._v(", or possibly other\nfields. In order to punish them, then, we would have to check all header\nfields.")]),e._v(" "),a("p",[e._v("Note some header fields require the block itself to verify, which the light\nclient, by definition, does not possess, so it may not be possible to check\nthese fields. For now, then, "),a("code",[e._v("LunaticValidatorEvidence")]),e._v(" must be checked against\nall header fields which are a function of the application at previous blocks.\nThis includes "),a("code",[e._v("ValidatorsHash")]),e._v(", "),a("code",[e._v("NextValidatorsHash")]),e._v(", "),a("code",[e._v("ConsensusHash")]),e._v(",\n"),a("code",[e._v("AppHash")]),e._v(", and "),a("code",[e._v("LastResultsHash")]),e._v(". These should all match what's in the header\nfor the block that was actually committed at the corresponding height, and\nshould thus be easy to check.")]),e._v(" "),a("h2",{attrs:{id:"status"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),a("p",[e._v("Proposed.")]),e._v(" "),a("h2",{attrs:{id:"consequences"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[e._v("#")]),e._v(" Consequences")]),e._v(" "),a("h3",{attrs:{id:"positive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#positive"}},[e._v("#")]),e._v(" Positive")]),e._v(" "),a("ul",[a("li",[e._v("Tendermint will be able to detect & punish new types of misbehavior")]),e._v(" "),a("li",[e._v("light clients connected to multiple full nodes can help full nodes notice a\nfork faster")])]),e._v(" "),a("h3",{attrs:{id:"negative"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#negative"}},[e._v("#")]),e._v(" Negative")]),e._v(" "),a("ul",[a("li",[e._v("Accepting "),a("code",[e._v("ConflictingHeadersEvidence")]),e._v(" from light clients opens up a DDOS\nattack vector (same is fair for any RPC endpoint open to public; remember that\nRPC is not open by default).")])]),e._v(" "),a("h3",{attrs:{id:"neutral"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#neutral"}},[e._v("#")]),e._v(" Neutral")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Fork accountability spec"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"appendix-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#appendix-a"}},[e._v("#")]),e._v(" Appendix A")]),e._v(" "),a("p",[e._v("If there is an actual fork (full fork), a full node may follow either one or\nanother branch. So both H1 or H2 can be considered committed depending on which\nbranch the full node is following. It's supposed to halt if it notices an\nactual fork, but there's a small chance it doesn't.")])],1)}),[],!1,null,null,null);t.default=s.exports}}]);