(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{605:function(e,t,a){e.exports=a.p+"assets/img/tm-amnesia-attack.605cabaf.png"},695:function(e,t,a){"use strict";a.r(t);var o=a(1),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"adr-056-proving-amnesia-attacks"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#adr-056-proving-amnesia-attacks"}},[e._v("#")]),e._v(" ADR 056: Proving amnesia attacks")]),e._v(" "),o("h2",{attrs:{id:"changelog"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),o("ul",[o("li",[e._v("02.04.20: Initial Draft")]),e._v(" "),o("li",[e._v("06.04.20: Second Draft")]),e._v(" "),o("li",[e._v("10.06.20: Post Implementation Revision")]),e._v(" "),o("li",[e._v("19.08.20: Short Term Amnesia Alteration")])]),e._v(" "),o("h2",{attrs:{id:"context"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),o("p",[e._v("Whilst most created evidence of malicious behaviour is self evident such that any individual can verify them independently there are types of evidence, known collectively as global evidence, that require further collaboration from the network in order to accumulate enough information to create evidence that is individually verifiable and can therefore be processed through consensus. "),o("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Fork Accountability"),o("OutboundLink")],1),e._v(" has been coined to describe the entire process of detection, proving and punishing of malicious behaviour. This ADR addresses specifically how to prove an amnesia attack but also generally outlines how global evidence can be converted to individual evidence.")]),e._v(" "),o("h3",{attrs:{id:"amnesia-attack"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#amnesia-attack"}},[e._v("#")]),e._v(" Amnesia Attack")]),e._v(" "),o("p",[e._v("The currently only known form of global evidence stems from "),o("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md#flip-flopping",target:"_blank",rel:"noopener noreferrer"}},[e._v("flip flopping"),o("OutboundLink")],1),e._v(" attacks. The schematic below explains one scenario where an amnesia attack, a form of flip flopping, can occur such that two sets of honest nodes, C1 and C2, commit different blocks.")]),e._v(" "),o("p",[o("img",{attrs:{src:a(605),alt:""}})]),e._v(" "),o("ol",[o("li",[e._v("C1 and F send PREVOTE messages for block A.")]),e._v(" "),o("li",[e._v("C1 sends PRECOMMIT for round 1 for block A.")]),e._v(" "),o("li",[e._v("A new round is started, C2 and F send PREVOTE messages for a different block B.")]),e._v(" "),o("li",[e._v("C2 and F then send PRECOMMIT messages for block B.")]),e._v(" "),o("li",[e._v("F breaks the lock and goes back and sends PRECOMMIT messages in round 1 for block A.")])]),e._v(" "),o("p",[e._v("This creates a fork on the main chain.  Back to the past, another form of flip flopping, creates a light fork (capable of fooling those not involved in consensus). This is done in a similar fashion to the schematic above, however the validators C1 eventually progress and commit the block in Round 2 and then when a light client comes to validate the block at that height, the nodes take the precommits for Round 1 and forge their own precommits to produce what looks like a valid block for the light client.")]),e._v(" "),o("h2",{attrs:{id:"pretext"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#pretext"}},[e._v("#")]),e._v(" Pretext")]),e._v(" "),o("p",[e._v("An amnesia protocol was outlined in a previous revision of this ADR and for completeness has been appeneded at the bottom (Appendix A). However, under the circumstances of the impending IBC release it was adjudged that the protocol hadn't received enough rigour and could be potentially liable for opening other forms of misbehaviour especially considering that the nature of the protocol deemed all the nodes that committed for a certain block guilty until they proved their innocence.")]),e._v(" "),o("h2",{attrs:{id:"decision"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#decision"}},[e._v("#")]),e._v(" Decision")]),e._v(" "),o("p",[e._v("The decision surrounding amnesia attacks has both a short term and long term component. In the long term, a more sturdy protocol will need to be fleshed out and implemented. There is already draft documents outlining what such a protocol would look like and the resources it would require. In the short term, it was discussed whether the protocol should be completely removed or if there should remain some logic in handling the aforementioned scenarios.")]),e._v(" "),o("p",[e._v("The latter of the two options was decided chiefly because it is important for the tendermint incentivisation mechanism that such behavior towards a light client is not only detectable but punishable. The logic that will need to be in place will involve the bare minimum to enable manual intervention. This therefore requires the on-chain submission of the faulty header that the light client witnessed plus the storing of vote sets by validators.")]),e._v(" "),o("h2",{attrs:{id:"detailed-design"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#detailed-design"}},[e._v("#")]),e._v(" Detailed Design")]),e._v(" "),o("p",[e._v("The first part of this short term solution is the "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(" data structure. This has the following properties that differ from its prior implementation.")]),e._v(" "),o("ul",[o("li",[e._v("It bundles all the malicious validators together instead of splitting them into individual evidence")]),e._v(" "),o("li",[e._v("It can be submitted on the chain")]),e._v(" "),o("li",[e._v("It does, by itself, not indicate which validators in the set misbehaved and should be slashed. It is merely a prompt for manual investigation.")])]),e._v(" "),o("p",[e._v("Before going any further, it is also important to mention that "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(" should only be formed from a valid attack on the light client and measures should be put in place to ensure that no node can easily forge the evidence as a means of spamming the network.")]),e._v(" "),o("p",[e._v("The data structure for "),o("code",[e._v("PotentialAmensiaEvidence")]),e._v(" is as follows:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBQb3RlbnRpYWxBbW5lc2lhRXZpZGVuY2Ugc3RydWN0IHsKCSpTaWduZWRIZWFkZXIKfQo="}}),e._v(" "),o("p",[e._v("It conforms to the "),o("code",[e._v("Evidence")]),e._v(" interface where "),o("code",[e._v("Time()")]),e._v(" is the time of the heaer (note that this can be forged but must be within trusting period) and "),o("code",[e._v("Address()")]),e._v(" returns the bytes of all validators in the commit")]),e._v(" "),o("p",[o("code",[e._v("ValidateBasic()")]),e._v(" inherit from the validate basic of the signed header")]),e._v(" "),o("h3",{attrs:{id:"verification-of-potentialamensiaevidence"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#verification-of-potentialamensiaevidence"}},[e._v("#")]),e._v(" Verification of PotentialAmensiaEvidence")]),e._v(" "),o("p",[o("code",[e._v("PotentialAmensiaEvidence")]),e._v(" will be saved in the evidence pool and committed on chain if the following conditions are met.")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("The "),o("code",[e._v("SignedHeader")]),e._v(" is valid -> "),o("code",[e._v("ValidateBasic()")])])]),e._v(" "),o("li",[o("p",[e._v("The "),o("code",[e._v("ValidatorsHash")]),e._v(" of the header must be the same as the header that the node has committed. (else this is a lunatic attack)")])]),e._v(" "),o("li",[o("p",[e._v("The signatures of the commit must all be valid (for that header) "),o("code",[e._v("VerifyCommit()")]),e._v(" using the validator set the node has for that height.")])]),e._v(" "),o("li",[o("p",[e._v("The header hash must be different to the hash of the header that the node has.")])]),e._v(" "),o("li",[o("p",[e._v("The "),o("code",[e._v("Commit")]),e._v(" of the "),o("code",[e._v("SignedHeader")]),e._v(" must be for a different round than the "),o("code",[e._v("Commit")]),e._v(" of the header that the node has committed")])]),e._v(" "),o("li",[o("p",[e._v("The evidence must not have expired.")])])]),e._v(" "),o("p",[e._v("The second part of the short term solution is saving "),o("code",[e._v("VoteSet")]),e._v("'s to the evidence pool. In order to avoid overflowing the validators memory, only the relevant information will be taken from the voteSets and formed into\nthis specific struct")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBWb3Rlc1JlY29yZCBzdHJ1Y3QgewoJdm90ZXMgW10qVm90ZQp9Cg=="}}),e._v(" "),o("p",[e._v("These votes should all be precommit votes of the same height and round and will come from the consensus reactor. "),o("code",[e._v("VotesRecord")]),e._v(" will only be created in heights where there are more than 1 round and will be sent from consensus.\n"),o("code",[e._v("VotesRecord")]),e._v(" will also follow the same pruning algorithm as the rest of the evidence, being removed after expiring.")]),e._v(" "),o("p",[e._v("Implementing this is in the short term should be sufficient to detecting amnesia attacks using manual intervention which through off-chain conesnsus can lead to punishment and thus in itself act to disincentivise misbehaviour.")]),e._v(" "),o("h2",{attrs:{id:"status"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),o("p",[e._v("Proposed")]),e._v(" "),o("h2",{attrs:{id:"consequences"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[e._v("#")]),e._v(" Consequences")]),e._v(" "),o("h3",{attrs:{id:"positive"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#positive"}},[e._v("#")]),e._v(" Positive")]),e._v(" "),o("p",[e._v("Increasing fork detection and accountability makes the system more secure")]),e._v(" "),o("h3",{attrs:{id:"negative"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#negative"}},[e._v("#")]),e._v(" Negative")]),e._v(" "),o("p",[e._v("Non-responsive but honest nodes that are part of the suspect group that don't produce a proof will be punished")]),e._v(" "),o("p",[e._v("A delay between the detection of a fork and the punishment of one")]),e._v(" "),o("h3",{attrs:{id:"neutral"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#neutral"}},[e._v("#")]),e._v(" Neutral")]),e._v(" "),o("h2",{attrs:{id:"references"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://docs.google.com/document/d/11ZhMsCj3y7zIZz4udO9l25xqb0kl7gmWqNpGVRzOeyY/edit",target:"_blank",rel:"noopener noreferrer"}},[e._v("Fork accountability algorithm"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Fork accountability spec"),o("OutboundLink")],1)])]),e._v(" "),o("h2",{attrs:{id:"appendix-a-prior-amnesiaevidence-implementation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#appendix-a-prior-amnesiaevidence-implementation"}},[e._v("#")]),e._v(" Appendix A: Prior AmnesiaEvidence Implementation")]),e._v(" "),o("p",[e._v("As the distinction between these two attacks (amnesia and back to the past) can only be distinguished by confirming with all validators (to see if it is a full fork or a light fork), for the purpose of simplicity, these attacks will be treated as the same.")]),e._v(" "),o("p",[e._v("Currently, the evidence reactor is used to simply broadcast and store evidence. The idea of creating a new reactor for the specific task of verifying these attacks was briefly discussed, but it is decided that the current evidence reactor will be extended.")]),e._v(" "),o("p",[e._v("The process begins with a light client receiving conflicting headers (in the future this could also be a full node during fast sync or state sync), which it sends to a full node to analyse. As part of "),o("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-047-handling-evidence-from-light-client.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("evidence handling"),o("OutboundLink")],1),e._v(", this is extracted into potential amnesia evidence when the validator voted in more than one round for a different block.")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBQb3RlbnRpYWxBbW5lc2lhRXZpZGVuY2Ugc3RydWN0IHsKCVZvdGVBICp0eXBlcy5Wb3RlCglWb3RlQiAqdHlwZXMuVm90ZQoKCUhlaWdodHN0YW1wIGludDY0Cn0K"}}),e._v(" "),o("p",[o("em",[e._v("NOTE: There had been an earlier notion towards batching evidence against the entire set of validators all together but this has given way to individual processing predominantly to maintain consistency with the other forms of evidence. A more extensive breakdown can be found "),o("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/4729",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1)])]),e._v(" "),o("p",[e._v("The evidence will contain the precommit votes for a validator that voted for both rounds. If the validator voted in more than two rounds, then they will have multiple "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(" against them hence it is possible that there is multiple evidence for a validator in a single height but not for a single round. The votes should be all valid and the height and time that the infringement was made should be within:")]),e._v(" "),o("p",[o("code",[e._v("MaxEvidenceAge - ProofTrialPeriod")])]),e._v(" "),o("p",[e._v("This trial period will be discussed later.")]),e._v(" "),o("p",[e._v("Returning to the event of an amnesia attack, if we were to examine the behaviour of the honest nodes, C1 and C2, in the schematic, C2 will not PRECOMMIT an earlier round, but it is likely, if a node in C1 were to receive +2/3 PREVOTE's or PRECOMMIT's for a higher round, that it would remove the lock and PREVOTE and PRECOMMIT for the later round. Therefore, unfortunately it is not a case of simply punishing all nodes that have double voted in the "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(".")]),e._v(" "),o("p",[e._v("Instead we use the Proof of Lock Change (PoLC) referred to in the "),o("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/consensus/consensus.md#terms",target:"_blank",rel:"noopener noreferrer"}},[e._v("consensus spec"),o("OutboundLink")],1),e._v(". When an honest node votes again for a different block in a later round\n(which will only occur in very rare cases), it will generate the PoLC and store it in the evidence reactor for a time equal to the "),o("code",[e._v("MaxEvidenceAge")])]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBQcm9vZk9mTG9ja0NoYW5nZSBzdHJ1Y3QgewoJVm90ZXMgW10qdHlwZXMuVm90ZQoJUHViS2V5IGNyeXB0by5QdWJLZXkKfQo="}}),e._v(" "),o("p",[e._v("This can be either evidence of +2/3 PREVOTES or PRECOMMITS (either warrants the honest node the right to vote) and is valid, among other checks, so long as the PRECOMMIT vote of the node in V2 came after all the votes in the "),o("code",[e._v("ProofOfLockChange")]),e._v(" i.e. it received +2/3 votes for a block and then voted for that block thereafter (F is unable to prove this).")]),e._v(" "),o("p",[e._v("In the event that an honest node receives "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(" it will first "),o("code",[e._v("ValidateBasic()")]),e._v(" and "),o("code",[e._v("Verify()")]),e._v(" it and then will check if it is among the suspected nodes in the evidence. If so, it will retrieve the "),o("code",[e._v("ProofOfLockChange")]),e._v(" and combine it with "),o("code",[e._v("PotentialAmensiaEvidence")]),e._v(" to form "),o("code",[e._v("AmensiaEvidence")]),e._v(". All honest nodes that are part of the indicted group will have a time, measured in blocks, equal to "),o("code",[e._v("ProofTrialPeriod")]),e._v(", the aforementioned evidence paramter, to gossip their "),o("code",[e._v("AmnesiaEvidence")]),e._v(" with their "),o("code",[e._v("ProofOfLockChange")])]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBBbW5lc2lhRXZpZGVuY2Ugc3RydWN0IHsKCSp0eXBlcy5Qb3RlbnRpYWxBbW5lc2lhRXZpZGVuY2UKCVBvbGMgICAqdHlwZXMuUHJvb2ZPZkxvY2tDaGFuZ2UKfQo="}}),e._v(" "),o("p",[e._v("If the node is not required to submit any proof than it will simply broadcast the "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(", stamp the height that it received the evidence and begin to wait out the trial period. It will ignore other "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(" gossiped at the same height and round.")]),e._v(" "),o("p",[e._v("If a node receives "),o("code",[e._v("AmnesiaEvidence")]),e._v(" that contains a valid "),o("code",[e._v("ProofOfClockChange")]),e._v(" it will add it to the evidence store and replace any PotentialAmnesiaEvidence of the same height and round. At this stage, an amnesia evidence with polc, it is ready to be submitted to the chin. If a node receives "),o("code",[e._v("AmnesiaEvidence")]),e._v(" with an empty polc it will ignore it as each honest node will conduct their own trial period to be sure that time was given for any other honest nodes to respond.")]),e._v(" "),o("p",[e._v("There can only be one "),o("code",[e._v("AmnesiaEvidence")]),e._v(" and one "),o("code",[e._v("PotentialAmneisaEvidence")]),e._v(" stored for each attack (i.e. for each height).")]),e._v(" "),o("p",[e._v("When, "),o("code",[e._v("state.LastBlockHeight > PotentialAmnesiaEvidence.timestamp + ProofTrialPeriod")]),e._v(", nodes will upgrade the corresponding "),o("code",[e._v("PotentialAmnesiaEvidence")]),e._v(" and attach an empty "),o("code",[e._v("ProofOfLockChange")]),e._v(". Then honest validators of the current validator set can begin proposing the block that contains the "),o("code",[e._v("AmnesiaEvidence")]),e._v(".")]),e._v(" "),o("p",[o("em",[e._v("NOTE: Even before the evidence is proposed and committed, the off-chain process of gossiping valid evidence could be\nenough for honest nodes to recognize the fork and halt.")])]),e._v(" "),o("p",[e._v("Other validators will vote "),o("nil",[e._v(" if:")])],1),e._v(" "),o("ul",[o("li",[e._v("The Amnesia Evidence is not valid")]),e._v(" "),o("li",[e._v("The Amensia Evidence is not within their own trial period i.e. too soon.")]),e._v(" "),o("li",[e._v("They don't have the Amnesia Evidence and it is has an empty polc (each validator needs to run their own trial period of the evidence)")]),e._v(" "),o("li",[e._v("Is of an AmnesiaEvidence that has already been committed to the chain.")])]),e._v(" "),o("p",[e._v("Finally it is important to stress that the protocol of having a trial period addresses attacks where a validator voted again for a different block at a later round and time. In the event, however, that the validator voted for an earlier round after voting for a later round i.e. "),o("code",[e._v("VoteA.Timestamp < VoteB.Timestamp && VoteA.Round > VoteB.Round")]),e._v(" then this action is inexcusable and can be punished immediately without the need of a trial period. In this case, PotentialAmnesiaEvidence will be instantly upgraded to AmnesiaEvidence.")])],1)}),[],!1,null,null,null);t.default=i.exports}}]);